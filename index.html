<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebXR Dichoptic – Shiny Helix (Objects Only)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; color:#ddd; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    #ui { position: fixed; left: 12px; top: 12px; background: rgba(0,0,0,0.55); padding: 10px 12px; border-radius: 12px; backdrop-filter: blur(6px); border: 1px solid rgba(255,255,255,0.08); max-width: 650px; z-index: 1000; max-height: 86vh; overflow: auto; }
    #ui label { display:block; font-size:13px; margin:6px 0 2px; }
    #ui .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .section { border-top: 1px dashed rgba(255,255,255,0.15); margin-top:8px; padding-top:8px; }
    .hidden { display:none !important; }
    .tag { font-size: 11px; padding: 2px 6px; border: 1px solid rgba(255,255,255,.2); border-radius: 999px; opacity:.9 }
    #diag { font-size:12px; color:#ffd18a; white-space:pre-line; margin-top:6px; }
    #testStatus{ font-size:12px; margin-top:6px; max-height:140px; overflow:auto; }
    .webxr-button, .vr-button, .xr-button { position: fixed !important; right: 12px !important; bottom: 12px !important; z-index: 2000 !important; opacity: 1 !important; display: block !important; }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="ui">
    <div class="row" style="justify-content:space-between; align-items:center">
      <strong>양안 분리 – 샤이니 헬릭스</strong>
      <span id="ambTag" class="tag">약시안: <strong>오른쪽</strong></span>
    </div>

    <div class="row">
      <button id="toggleAmb">약시안 좌/우 전환</button>
      <button id="enter">VR 시작</button>
      <button id="recenter">재배치</button>
      <button id="runTests">자가 테스트</button>
    </div>

    <label>배경 패턴</label>
    <div class="row">
      <select id="bgMode">
        <option value="sine" selected>사인</option>
        <option value="checker">체커</option>
        <option value="spiral">스파이럴</option>
      </select>
      <label style="margin-left:8px">색1</label>
      <input id="bgColor1" type="color" value="#101010"/>
      <label>색2</label>
      <input id="bgColor2" type="color" value="#1b1b1b"/>
    </div>

    <div id="objectsPanel">
      <div class="row"><strong>왼/오 눈 형태·색</strong></div>
      <div class="row">
        <label>왼쪽</label>
        <input id="leftColor" type="color" value="#ff4da6" />
        <select id="leftShape">
          <option value="helix" selected>헬릭스</option>
          <option value="cube">큐브</option>
          <option value="sphere">스피어</option>
          <option value="ring">링</option>
        </select>
        <label style="margin-left:8px">오른쪽</label>
        <input id="rightColor" type="color" value="#3ddcff" />
        <select id="rightShape">
          <option value="helix" selected>헬릭스</option>
          <option value="cube">큐브</option>
          <option value="sphere">스피어</option>
          <option value="ring">링</option>
        </select>
      </div>
      <label>헬릭스 두께 (tube r, m)</label>
      <div class="row">
        <input id="helixThickness" type="range" min="0.01" max="0.20" step="0.005" value="0.035"/>
        <span id="helixThicknessVal">0.035</span>
      </div>
    </div>

    <label>공통(양눈) 자극</label>
    <div class="row">
      <input id="bothColor" type="color" value="#888888" />
      <select id="bothShape">
        <option value="grid" selected>그리드(중앙 십자)</option>
        <option value="floor">바닥 플레인</option>
        <option value="none">없음</option>
      </select>
      <button id="clearBoth">제거</button>
      <label style="margin-left:8px"><input type="checkbox" id="fusionToggle" checked> 중앙 십자 표시</label>
    </div>

    <div class="section">
      <div class="row"><strong>선명도(HD/SD) & 샤이니(메탈) — 약시안만</strong></div>
      <div class="row">
        <label>약시안 선명도</label>
        <input id="ambSharp" type="range" min="0" max="1" step="0.05" value="0.8">
        <span id="ambSharpVal">0.80</span>
        <label style="margin-left:8px">우세안 SD 강도</label>
        <input id="domSD" type="range" min="0" max="1" step="0.05" value="0.6">
        <span id="domSDVal">0.60</span>
      </div>
      <div class="row">
        <label><input id="shinyAmb" type="checkbox" checked> 약시안 샤이니(메탈 하이라이트)</label>
        <label style="margin-left:8px">metalness</label>
        <input id="shinyMetal" type="range" min="0" max="1" step="0.01" value="1.0"><span id="shinyMetalVal">1.00</span>
        <label>roughness</label>
        <input id="shinyRough" type="range" min="0" max="1" step="0.01" value="0.08"><span id="shinyRoughVal">0.08</span>
        <label>clearcoat</label>
        <input id="shinyCoat" type="range" min="0" max="1" step="0.01" value="0.9"><span id="shinyCoatVal">0.90</span>
        <label>env</label>
        <input id="shinyEnv" type="range" min="0" max="5" step="0.1" value="2.5"><span id="shinyEnvVal">2.5</span>
        <label>emissive</label>
        <input id="shinyEmi" type="range" min="0" max="0.6" step="0.02" value="0.12"><span id="shinyEmiVal">0.12</span>
      </div>
      <div class="row">
        <label>렌더 스케일</label>
        <input id="renderScale" type="range" min="1" max="2" step="0.05" value="1.6"><span id="renderScaleVal">1.60×</span>
        <label style="margin-left:8px"><input id="ambSparkle" type="checkbox" checked> 약시안 헬릭스 반짝임</label>
      </div>
    </div>

    <div class="section">
      <div class="row"><strong>템포랄 모듈레이션(깜빡임)</strong></div>
      <div class="row">
        <label><input type="checkbox" id="modL"> 왼눈 적용</label>
        <label><input type="checkbox" id="modR" checked> 오른눈 적용</label>
        <label>모드</label>
        <select id="modMode">
          <option value="blink">온/오프</option>
          <option value="pulse" selected>명암+대비+색 펄스</option>
        </select>
        <label>주파수(Hz)</label>
        <input id="modFreq" type="range" min="0" max="15" step="0.1" value="2">
        <span id="modFreqVal">2.0 Hz</span>
        <label>듀티(%)</label>
        <input id="modDuty" type="range" min="5" max="95" step="1" value="50">
        <span id="modDutyVal">50%</span>
      </div>
      <div class="row">
        <label>펄스 강도</label>
        <input id="pulseStrength" type="range" min="0.5" max="2.0" step="0.05" value="1.3">
        <span id="pulseStrengthVal">1.30×</span>
        <label style="margin-left:8px"><input type="checkbox" id="phaseLink"> 위상 모드(좌↔우 연동)</label>
        <label>오프셋(°)</label>
        <input id="phaseOffset" type="range" min="0" max="180" step="1" value="0" disabled>
        <span id="phaseOffsetVal">0°</span>
      </div>
      <div class="row">
        <label>개별 위상 L(°)</label>
        <input id="phaseL" type="range" min="0" max="360" step="1" value="0">
        <span id="phaseLVal">0°</span>
        <label style="margin-left:8px">개별 위상 R(°)</label>
        <input id="phaseR" type="range" min="0" max="360" step="1" value="0">
        <span id="phaseRVal">0°</span>
      </div>
    </div>

    <div id="testStatus"></div>
    <div id="diag"></div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

    const diag = document.getElementById('diag');
    function d(msg){ diag.textContent += (diag.textContent?'\n':'')+msg; console.log('[DIAG]', msg); }

    // Renderer / Scene
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.xr.enabled = true; document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 50);
    camera.position.set(0,1.4,1.5); camera.layers.enable(0); camera.layers.enable(1); camera.layers.enable(2);

    // Lighting & Environment (for shiny metal look even in dark)
    const pmrem = new THREE.PMREMGenerator(renderer);
    const env = pmrem.fromScene(new RoomEnvironment(renderer), 0.1).texture;
    scene.environment = env; // reflections
    const hemi = new THREE.HemisphereLight(0xffffff, 0x111122, 0.7); scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.35); dir.position.set(2,2,1); scene.add(dir);

    // Background
    const bgGeom = new THREE.PlaneGeometry(20, 12);
    const bgMat = new THREE.ShaderMaterial({
      uniforms:{ uTime:{value:0}, uColor1:{value:new THREE.Color('#101010')}, uColor2:{value:new THREE.Color('#1b1b1b')}, uMode:{value:0} },
      vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
      fragmentShader:`uniform float uTime; uniform vec3 uColor1,uColor2; uniform int uMode; varying vec2 vUv; float checker(vec2 p){ vec2 c=floor(p); return mod(c.x+c.y,2.0);} void main(){ vec2 uv=vUv; float m=0.0; if(uMode==0){ float w1=0.5+0.5*sin((uv.y*7.0+uTime*0.4)+0.35*sin(uv.x*9.0+uTime*0.7)); float w2=0.5+0.5*sin((uv.x*5.0-uTime*0.5)+0.20*sin(uv.y*11.0-uTime*0.3)); m=clamp(0.35+0.65*(0.6*w1+0.4*w2),0.0,1.0);} else if(uMode==1){ vec2 p=uv*16.0+vec2(uTime*0.15,-uTime*0.12); m=checker(p);} else { vec2 p=(uv-0.5)*2.0; float r=length(p); float a=atan(p.y,p.x); m=0.5+0.5*sin(12.0*a+8.0*r-uTime*1.0);} vec3 col=mix(uColor1,uColor2,m); gl_FragColor=vec4(col,1.0);} `,
      depthWrite:false
    });
    const bg = new THREE.Mesh(bgGeom, bgMat); bg.position.set(0,1.4,-3.0); bg.layers.set(0); scene.add(bg);

    // Grid / both-eye cue
    const grid = new THREE.GridHelper(8, 24, 0xffffff, 0x666666); grid.material.opacity=0.25; grid.material.transparent=true; grid.position.y=0; scene.add(grid);

    // Groups
    const leftGroup = new THREE.Group(); const rightGroup = new THREE.Group(); const bothGroup = new THREE.Group(); scene.add(leftGroup,rightGroup,bothGroup);

    // Helix geometry helper
    class HelixCurve extends THREE.Curve { constructor(radius=0.18, pitch=0.28, turns=3.2){ super(); this.r=radius; this.p=pitch; this.t=turns; } getPoint(t){ const ang=this.t*6.28318530718*t; return new THREE.Vector3(this.r*Math.cos(ang),(t-0.5)*this.p*this.t,this.r*Math.sin(ang)); } }
    let tubeRadius = 0.035;

    // Material factory
    function makeMaterial(color, shiny=false){
      const c = new THREE.Color(color);
      if(shiny){
        const m = new THREE.MeshPhysicalMaterial({ color:c, metalness:1.0, roughness:0.08, clearcoat:0.9, clearcoatRoughness:0.15, envMapIntensity:2.5, emissive:c.clone().multiplyScalar(0.12) });
        return m;
      }
      return new THREE.MeshStandardMaterial({ color:c, metalness:0.15, roughness:0.4, transparent:true, opacity:1.0 });
    }

    function makeMesh(shape, color, shiny=false){
      if(shape==='helix'){
        const curve=new HelixCurve(0.18,0.28,3.2);
        const geo=new THREE.TubeGeometry(curve, 240, tubeRadius, 32, false);
        const mat=makeMaterial(color, shiny);
        return new THREE.Mesh(geo, mat);
      }
      const mat=makeMaterial(color, shiny);
      let geo; if(shape==='cube') geo=new THREE.BoxGeometry(0.35,0.35,0.35); else if(shape==='sphere') geo=new THREE.SphereGeometry(0.26,32,24); else if(shape==='ring') geo=new THREE.TorusGeometry(0.30,0.08,20,120); else geo=new THREE.BoxGeometry(0.3,0.3,0.3);
      return new THREE.Mesh(geo, mat);
    }

    // Initial meshes
    let leftMesh = makeMesh('helix', 0xff4da6, false);
    let rightMesh = makeMesh('helix', 0x3ddcff, true); // 약시안 기본=오른쪽이므로 샤이니 적용
    let bothMesh = null;
    leftMesh.position.set(-0.42,1.45,-1.25); rightMesh.position.set(0.42,1.45,-1.25);
    leftMesh.layers.set(1); rightMesh.layers.set(2); leftGroup.add(leftMesh); rightGroup.add(rightMesh);

    // Sparkle (amb eye only)
    let sparkle=null;
    function buildSparkleFor(mesh, color){
      if(sparkle){ (sparkle.parent?.remove?.(sparkle)); sparkle.geometry?.dispose?.(); sparkle.material?.dispose?.(); sparkle=null; }
      const N=800; const g=new THREE.BufferGeometry(); const pos=new Float32Array(N*3); const ph=new Float32Array(N);
      for(let i=0;i<N;i++){ const a=Math.random()*Math.PI*2*3.2; const r=0.18+(Math.random()*0.05); const x=r*Math.cos(a); const z=r*Math.sin(a); const y=(Math.random()-0.5)*0.28*3.2; pos[i*3]=mesh.position.x + x + (Math.random()-0.5)*0.03; pos[i*3+1]=1.45+y + (Math.random()-0.5)*0.03; pos[i*3+2]=-1.25+z + (Math.random()-0.5)*0.03; ph[i]=Math.random()*Math.PI*2; }
      g.setAttribute('position', new THREE.BufferAttribute(pos,3)); g.setAttribute('phase', new THREE.BufferAttribute(ph,1));
      const m=new THREE.ShaderMaterial({
        uniforms:{ uColor:{value:new THREE.Color(color)} },
        vertexShader:`attribute float phase; varying float vP; void main(){ vP=phase; gl_PointSize=1.6 + 1.6*abs(sin(phase)); gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
        fragmentShader:`uniform vec3 uColor; varying float vP; void main(){ float d=length(gl_PointCoord-vec2(0.5)); float halo=smoothstep(0.5,0.0,d); float tw=0.6 + 0.4*abs(sin(vP)); gl_FragColor=vec4(uColor, halo*tw); }`,
        transparent:true, depthWrite:false, blending:THREE.AdditiveBlending
      });
      sparkle=new THREE.Points(g,m);
      sparkle.layers.set(mesh.layers.mask===2?2:1);
      (mesh.layers.mask===2? rightGroup : leftGroup).add(sparkle);
    }

    // Helpers
    function safeDispose(obj){ if(!obj) return; obj.traverse?.(c=>{ if(c.isMesh){ c.geometry?.dispose?.(); const m=c.material; if(Array.isArray(m)) m.forEach(x=>x?.dispose?.()); else m?.dispose?.(); } }); }
    function setGroupColor(obj,color){ if(!obj) return; const col=new THREE.Color(color); obj.traverse(c=>{ if(c.isMesh){ if(Array.isArray(c.material)) c.material.forEach(m=>m?.color?.set(col)); else c.material?.color?.set(col);} }); }
    function setPerEyeLayers(){ const xrCam=renderer.xr.getCamera(camera); if(xrCam?.cameras?.length>=2){ const camL=xrCam.cameras[0], camR=xrCam.cameras[1]; camL.layers.enable(0); camL.layers.enable(1); camL.layers.disable(2); camR.layers.enable(0); camR.layers.enable(2); camR.layers.disable(1);} }

    // Both-eye cue
    function setBoth(shape, color){ if(bothMesh){ bothGroup.remove(bothMesh); safeDispose(bothMesh); bothMesh=null; } if(shape==='grid'){ const g=new THREE.Group(); const m=new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.6 }); const bar1=new THREE.Mesh(new THREE.PlaneGeometry(0.02,0.30), m.clone()); const bar2=new THREE.Mesh(new THREE.PlaneGeometry(0.30,0.02), m.clone()); bar1.position.set(0,1.5,-1.2); bar2.position.set(0,1.5,-1.2); g.add(bar1,bar2); bothMesh=g; } else if(shape==='floor'){ const plane=new THREE.Mesh(new THREE.PlaneGeometry(8,8), new THREE.MeshStandardMaterial({ color, metalness:0, roughness:1, transparent:true, opacity:1 })); plane.rotation.x=-Math.PI/2; plane.position.y=0.001; bothMesh=plane; } if(bothMesh) bothGroup.add(bothMesh); }
    setBoth('grid', '#888888');

    // === UI refs ===
    const leftColor=document.getElementById('leftColor'); const rightColor=document.getElementById('rightColor'); const bothColor=document.getElementById('bothColor');
    const leftShape=document.getElementById('leftShape'); const rightShape=document.getElementById('rightShape'); const bothShape=document.getElementById('bothShape');
    const fusionToggle=document.getElementById('fusionToggle'); const testStatus=document.getElementById('testStatus');
    const modL=document.getElementById('modL'); const modR=document.getElementById('modR'); const modMode=document.getElementById('modMode'); const modFreq=document.getElementById('modFreq'); const modFreqVal=document.getElementById('modFreqVal'); const modDuty=document.getElementById('modDuty'); const modDutyVal=document.getElementById('modDutyVal'); const pulseStrength=document.getElementById('pulseStrength'); const pulseStrengthVal=document.getElementById('pulseStrengthVal'); const phaseLink=document.getElementById('phaseLink'); const phaseOffset=document.getElementById('phaseOffset'); const phaseOffsetVal=document.getElementById('phaseOffsetVal'); const phaseL=document.getElementById('phaseL'); const phaseR=document.getElementById('phaseR'); const phaseLVal=document.getElementById('phaseLVal'); const phaseRVal=document.getElementById('phaseRVal');
    const bgMode=document.getElementById('bgMode'); const bgColor1=document.getElementById('bgColor1'); const bgColor2=document.getElementById('bgColor2');
    const helixThickness=document.getElementById('helixThickness'); const helixThicknessVal=document.getElementById('helixThicknessVal');
    const toggleAmb=document.getElementById('toggleAmb'); const ambTag=document.getElementById('ambTag');
    const ambSharpEl=document.getElementById('ambSharp'); const ambSharpVal=document.getElementById('ambSharpVal');
    const domSDEl=document.getElementById('domSD'); const domSDVal=document.getElementById('domSDVal');
    const shinyAmb=document.getElementById('shinyAmb'); const shinyMetal=document.getElementById('shinyMetal'); const shinyMetalVal=document.getElementById('shinyMetalVal'); const shinyRough=document.getElementById('shinyRough'); const shinyRoughVal=document.getElementById('shinyRoughVal'); const shinyCoat=document.getElementById('shinyCoat'); const shinyCoatVal=document.getElementById('shinyCoatVal'); const shinyEnv=document.getElementById('shinyEnv'); const shinyEnvVal=document.getElementById('shinyEnvVal'); const shinyEmi=document.getElementById('shinyEmi'); const shinyEmiVal=document.getElementById('shinyEmiVal');
    const renderScale=document.getElementById('renderScale'); const renderScaleVal=document.getElementById('renderScaleVal');

    // Amb eye side
    let ambEye = 'R';
    function updateAmbTag(){ ambTag.innerHTML = `약시안: <strong>${ambEye==='R'?'오른쪽':'왼쪽'}</strong>`; }
    updateAmbTag();

    // Shiny apply helper
    function applyShinyTo(mesh, color, on){
      const m = makeMaterial(color, on);
      m.envMapIntensity = Number(shinyEnv.value);
      if(m.isMeshPhysicalMaterial){ m.metalness = Number(shinyMetal.value); m.roughness = Number(shinyRough.value); m.clearcoat = Number(shinyCoat.value); m.emissive = new THREE.Color(color).multiplyScalar(Number(shinyEmi.value)); }
      const old = mesh.material; mesh.material = m; if(old && old!==m){ if(Array.isArray(old)) old.forEach(x=>x?.dispose?.()); else old?.dispose?.(); }
    }

    function rebuildSide(which){
      const isLeft = (which==='L'); const shapeSel=isLeft?leftShape:rightShape; const colInput=isLeft?leftColor:rightColor; const group=isLeft?leftGroup:rightGroup; let mesh=isLeft?leftMesh:rightMesh; const shiny = shinyAmb.checked && ((ambEye==='L' && isLeft) || (ambEye==='R' && !isLeft?false:true));
      group.remove(mesh); safeDispose(mesh);
      mesh = makeMesh(shapeSel.value, colInput.value, shiny && ((ambEye==='L' && isLeft) || (ambEye==='R' && !isLeft?false:true)));
      mesh.position.copy(isLeft? new THREE.Vector3(-0.42,1.45,-1.25) : new THREE.Vector3(0.42,1.45,-1.25));
      mesh.layers.set(isLeft?1:2); group.add(mesh);
      if(isLeft) leftMesh=mesh; else rightMesh=mesh;
      if(shinyAmb.checked){ // re-apply fine params
        if((ambEye==='L' && isLeft) || (ambEye==='R' && !isLeft?false:true)) applyShinyTo(mesh, colInput.value, true);
      }
      // sparkle for amb eye helix only
      if((ambEye==='L' && isLeft) || (ambEye==='R' && !isLeft?false:true)){
        if(shapeSel.value==='helix' && document.getElementById('ambSparkle').checked) buildSparkleFor(mesh, colInput.value); else if(sparkle){ sparkle.parent?.remove?.(sparkle); sparkle.geometry?.dispose?.(); sparkle.material?.dispose?.(); sparkle=null; }
      }
    }

    // Colors / shapes listeners
    leftColor.addEventListener('input', ()=>{ if(leftMesh?.material) leftMesh.material.color.set(leftColor.value); if(ambEye==='L' && shinyAmb.checked) applyShinyTo(leftMesh,leftColor.value,true); if(sparkle && ambEye==='L') buildSparkleFor(leftMesh, leftColor.value); });
    rightColor.addEventListener('input', ()=>{ if(rightMesh?.material) rightMesh.material.color.set(rightColor.value); if(ambEye==='R' && shinyAmb.checked) applyShinyTo(rightMesh,rightColor.value,true); if(sparkle && ambEye==='R') buildSparkleFor(rightMesh, rightColor.value); });
    leftShape.addEventListener('change', ()=> rebuildSide('L'));
    rightShape.addEventListener('change', ()=> rebuildSide('R'));

    // Helix thickness
    helixThickness.addEventListener('input', ()=>{ helixThicknessVal.textContent = Number(helixThickness.value).toFixed(3); });
    helixThickness.addEventListener('change', ()=>{ tubeRadius=Number(helixThickness.value); rebuildSide('L'); rebuildSide('R'); });

    // Both cue
    bothColor.addEventListener('input', ()=>{ if(bothMesh) setGroupColor(bothMesh, bothColor.value); });
    bothShape.addEventListener('change', ()=> setBoth(bothShape.value, bothColor.value));
    document.getElementById('clearBoth').addEventListener('click', ()=>{ setBoth('none'); bothShape.value='none'; document.getElementById('fusionToggle').checked=false; });
    fusionToggle.addEventListener('change', ()=>{ if (fusionToggle.checked){ setBoth('grid', bothColor.value); bothShape.value='grid'; } else { setBoth('none'); bothShape.value='none'; } });

    // BG controls
    document.getElementById('bgMode').addEventListener('change', ()=>{ bgMat.uniforms.uMode.value = (bgMode.value==='sine'?0:(bgMode.value==='checker'?1:2)); });
    document.getElementById('bgColor1').addEventListener('input', ()=>{ bgMat.uniforms.uColor1.value.set(bgColor1.value); });
    document.getElementById('bgColor2').addEventListener('input', ()=>{ bgMat.uniforms.uColor2.value.set(bgColor2.value); });

    // Render scale (for crisp highlights)
    renderScale.addEventListener('input', ()=>{ const s=Number(renderScale.value); renderer.setPixelRatio(Math.min(2, s)); renderScaleVal.textContent = s.toFixed(2)+'×'; });

    // Sharpness / SD
    let ambSharp=Number(ambSharpEl.value), domSD=Number(domSDEl.value);
    ambSharpEl.addEventListener('input', ()=>{ ambSharp=Number(ambSharpEl.value); ambSharpVal.textContent=ambSharp.toFixed(2); });
    domSDEl.addEventListener('input', ()=>{ domSD=Number(domSDEl.value); domSDVal.textContent=domSD.toFixed(2); });

    // Shiny params
    function shinyReadouts(){ shinyMetalVal.textContent=Number(shinyMetal.value).toFixed(2); shinyRoughVal.textContent=Number(shinyRough.value).toFixed(2); shinyCoatVal.textContent=Number(shinyCoat.value).toFixed(2); shinyEnvVal.textContent=Number(shinyEnv.value).toFixed(1); shinyEmiVal.textContent=Number(shinyEmi.value).toFixed(2); }
    ;[shinyMetal,shinyRough,shinyCoat,shinyEnv,shinyEmi].forEach(el=>el.addEventListener('input', ()=>{ shinyReadouts(); if(ambEye==='L') applyShinyTo(leftMesh,leftColor.value,shinyAmb.checked); else applyShinyTo(rightMesh,rightColor.value,shinyAmb.checked); }));
    shinyAmb.addEventListener('change', ()=>{ rebuildSide('L'); rebuildSide('R'); });
    shinyReadouts();

    // Temporal modulation
    function blinkValue(t,freq,duty,phaseDeg){ if(freq<=0) return 1; const phase=(phaseDeg||0)*Math.PI/180; const period=1/freq; const ph=((t+phase/(2*Math.PI*freq))%period+period)%period; return (ph<duty*period)?1:0; }
    function pulseValue(t,freq,phaseDeg){ if(freq<=0) return 1; const phase=(phaseDeg||0)*Math.PI/180; const v=0.5+0.5*Math.sin(2*Math.PI*freq*t+phase); return 0.2+0.8*v; }
    function applyPulse(mesh,v){ const s=Number(pulseStrength.value); mesh.visible=true; mesh.material.opacity=Math.min(1, 0.2+0.8*v*s*0.9); const base=new THREE.Color(mesh===leftMesh?leftColor.value:rightColor.value); const gray=new THREE.Color(0.45,0.45,0.45); const amount=(v-0.5)*2; if(amount>=0){ const boosted=base.clone(); const k=0.6*s; boosted.r=Math.min(1, Math.pow(base.r,0.8)+k*0.4); boosted.g=Math.min(1, Math.pow(base.g,0.8)+k*0.4); boosted.b=Math.min(1, Math.pow(base.b,0.8)+k*0.4); mesh.material.color.copy(base.clone().lerp(boosted, Math.min(1, amount*(0.7+0.3*s)))); } else { const att=Math.min(1, (-amount)*(0.6+0.4*s)); mesh.material.color.copy(base.clone().lerp(gray, att)); } mesh.material.needsUpdate=true; }
    function applyTemporal(mesh, enabled, mode, t, phaseDeg){ if(!mesh) return; if(!enabled){ mesh.visible=true; mesh.material.opacity=1.0; mesh.material.color.set(mesh===leftMesh?leftColor.value:rightColor.value); return; } if(mode==='blink'){ const v=blinkValue(t, Number(modFreq.value), Number(modDuty.value)/100, phaseDeg); mesh.visible=(v>=0.5); } else { const v=pulseValue(t, Number(modFreq.value), phaseDeg); applyPulse(mesh, v); } }

    // Dominant SD & Amb sharp effect
    function applyPerEyeClarity(){
      const domMesh = (ambEye==='R'? leftMesh : rightMesh);
      if(domMesh && domMesh.material){ const baseCol = new THREE.Color(ambEye==='R'?leftColor.value:rightColor.value); const gray=new THREE.Color(0.5,0.5,0.5); const c = baseCol.clone().lerp(gray, domSD*0.8); domMesh.material.color.copy(c); domMesh.material.opacity = 1.0 - domSD*0.2; domMesh.material.needsUpdate=true; }
      const ambMesh = (ambEye==='R'? rightMesh : leftMesh);
      if(ambMesh && ambMesh.material){ const baseCol = new THREE.Color(ambEye==='R'?rightColor.value:leftColor.value); const boost = baseCol.clone(); boost.r=Math.min(1, Math.pow(boost.r, 0.85)); boost.g=Math.min(1, Math.pow(boost.g, 0.85)); boost.b=Math.min(1, Math.pow(boost.b, 0.85)); ambMesh.material.color.copy(baseCol.clone().lerp(boost, ambSharp*0.6)); ambMesh.material.needsUpdate=true; }
    }

    // Amb toggle
    function updateAmbAssets(){ updateAmbTag(); // reassign shiny & sparkle side
      rebuildSide('L'); rebuildSide('R'); }
    toggleAmb.addEventListener('click', ()=>{ ambEye = (ambEye==='R'?'L':'R'); updateAmbAssets(); });

    // Animation
    renderer.setAnimationLoop((tMs)=>{
      const t=(tMs||0)/1000; bgMat.uniforms.uTime.value=t; leftMesh.rotation.y += 0.015; rightMesh.rotation.y -= 0.012;
      let lPhase=Number(phaseL.value), rPhase=Number(phaseR.value); if(phaseLink.checked){ rPhase=(lPhase+Number(phaseOffset.value))%360; }
      applyTemporal(leftMesh,  modL.checked, modMode.value, t, lPhase);
      applyTemporal(rightMesh, modR.checked, modMode.value, t, rPhase);
      applyPerEyeClarity();
      setPerEyeLayers();
      renderer.render(scene,camera);
    });

    // WebXR Button
    (async()=>{ try{ const btn=VRButton.createButton(renderer); btn.style.position='fixed'; btn.style.right='12px'; btn.style.bottom='12px'; btn.style.zIndex='2000'; document.body.appendChild(btn); d('VRButton 준비 완료'); } catch(e){ d('VRButton 생성 실패: '+(e?.message||e)); } })();
    document.getElementById('enter').addEventListener('click', ()=>{ const btn=document.querySelector('button.webxr-button, .webxr-button, .vr-button, .xr-button'); btn?.click?.(); });
    document.getElementById('recenter').addEventListener('click', ()=>{ camera.position.set(0,1.4,1.5); camera.lookAt(0,1.4,-1.2); });
    window.addEventListener('resize', ()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

    // UI text readouts
    modFreq.addEventListener('input', ()=>{ modFreqVal.textContent = `${Number(modFreq.value).toFixed(1)} Hz`; });
    modDuty.addEventListener('input', ()=>{ modDutyVal.textContent = `${modDuty.value}%`; });
    pulseStrength.addEventListener('input', ()=>{ pulseStrengthVal.textContent = `${Number(pulseStrength.value).toFixed(2)}×`; });
    phaseOffset.addEventListener('input', ()=>{ phaseOffsetVal.textContent = `${phaseOffset.value}°`; });
    phaseL.addEventListener('input', ()=>{ phaseLVal.textContent = `${phaseL.value}°`; });
    phaseR.addEventListener('input', ()=>{ phaseRVal.textContent = `${phaseR.value}°`; });
    phaseLink.addEventListener('change', ()=>{ phaseOffset.disabled=!phaseLink.checked; phaseR.disabled=!!phaseLink.checked; });

    // Self tests
    function logStatus(msg, ok=true){ const el=document.createElement('div'); el.textContent=(ok?'✅ ':'❌ ')+msg; el.style.color=ok?'#9fdf9f':'#ff9f9f'; testStatus.appendChild(el); (ok?console.log:console.error)('[TEST]', msg); }
    async function runSelfTests(){ testStatus.textContent=''; try{
      if(!(window && THREE)) throw new Error('THREE 모듈 미로드');
      if(!VRButton) throw new Error('VRButton 미로드 실패');
      if(!RoomEnvironment) throw new Error('RoomEnvironment 미로드 실패');
      logStatus('모듈 로드(THREE/VRButton/RoomEnvironment) OK');
      setBoth('grid', '#888'); setBoth('floor', '#555'); setBoth('none'); setBoth('grid', '#888'); logStatus('setBoth 전이( grid → floor → none → grid ) OK');
      bothColor.value = '#ff0000'; bothColor.dispatchEvent(new Event('input')); logStatus('bothColor 핸들러 OK');
      ['cube','sphere','ring','helix'].forEach(s=>{ leftShape.value=s; leftShape.dispatchEvent(new Event('change')); rightShape.value=s; rightShape.dispatchEvent(new Event('change')); }); logStatus('좌/우 shape 연속 변경 & dispose 안전성 OK');
      phaseLink.checked=true; phaseLink.dispatchEvent(new Event('change')); phaseOffset.value='180'; phaseOffset.dispatchEvent(new Event('input')); phaseLink.checked=false; phaseLink.dispatchEvent(new Event('change')); phaseL.value='45'; phaseL.dispatchEvent(new Event('input')); phaseR.value='120'; phaseR.dispatchEvent(new Event('input')); logStatus('위상 연동/개별 모드 예외 없음');
      shinyAmb.checked=true; shinyAmb.dispatchEvent(new Event('change')); shinyMetal.value='1.0'; shinyMetal.dispatchEvent(new Event('input')); shinyRough.value='0.05'; shinyRough.dispatchEvent(new Event('input')); shinyEnv.value='3.0'; shinyEnv.dispatchEvent(new Event('input')); logStatus('샤이니 파라미터 적용 OK');
      renderScale.value='1.8'; renderScale.dispatchEvent(new Event('input')); logStatus('렌더 스케일 조정 OK');
      logStatus('모든 내장 테스트 통과');
    }catch(e){ logStatus('테스트 예외: '+(e?.message||e), false); }
    }
    document.getElementById('runTests').addEventListener('click', runSelfTests);

    // Initialize
    function init(){ camera.lookAt(0,1.4,-1.2); buildSparkleFor(rightMesh, rightColor.value); d('초기화: R=약시안, 샤이니/스파클/렌더스케일 포함.'); }
    init();
  </script>
</body>
</html>
